\documentclass{article}

\usepackage{fancyhdr}
\usepackage{extramarks}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage[plain]{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{minted}

\usetikzlibrary{automata,positioning}

%
% Basic Document Settings
%

\topmargin=-0.45in
\evensidemargin=0in
\oddsidemargin=0in
\textwidth=6.5in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1}

\pagestyle{fancy}
\lhead{\hmwkAuthorName}
\chead{\hmwkClass\ (\hmwkClassInstructor): \hmwkTitle}
\rhead{\firstxmark}
\lfoot{\lastxmark}
\cfoot{\thepage}

\renewcommand\headrulewidth{0.4pt}
\renewcommand\footrulewidth{0.4pt}

\setlength\parindent{0pt}

%
% Create Problem Sections
%

\newcommand{\enterProblemHeader}[1]{
    \nobreak\extramarks{}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
}

\newcommand{\exitProblemHeader}[1]{
    \nobreak\extramarks{Problem \arabic{#1} (continued)}{Problem \arabic{#1} continued on next page\ldots}\nobreak{}
    \stepcounter{#1}
    \nobreak\extramarks{Problem \arabic{#1}}{}\nobreak{}
}

\setcounter{secnumdepth}{0}
\newcounter{partCounter}
\newcounter{homeworkProblemCounter}
\setcounter{homeworkProblemCounter}{1}
\nobreak\extramarks{Problem \arabic{homeworkProblemCounter}}{}\nobreak{}

%
% Homework Problem Environment
%
% This environment takes an optional argument. When given, it will adjust the
% problem counter. This is useful for when the problems given for your
% assignment aren't sequential. See the last 3 problems of this template for an
% example.
%
\newenvironment{homeworkProblem}[1][-1]{
    \ifnum#1>0
        \setcounter{homeworkProblemCounter}{#1}
    \fi
    \section{Problem \arabic{homeworkProblemCounter}}
    \setcounter{partCounter}{1}
    \enterProblemHeader{homeworkProblemCounter}
}{
    \exitProblemHeader{homeworkProblemCounter}
}

%
% Homework Details
%   - Title
%   - Due date
%   - Class
%   - Section/Time
%   - Instructor
%   - Author
%

\newcommand{\hmwkTitle}{Homework\ \#4}
\newcommand{\hmwkDueDate}{October 15}
\newcommand{\hmwkClass}{CSC2125}
\newcommand{\hmwkClassTime}{}
\newcommand{\hmwkClassInstructor}{Fan Long}
\newcommand{\hmwkAuthorName}{\textbf{Thomas Hollis}}

%
% Title Page
%

\title{
    \vspace{2in}
    \textmd{\textbf{\hmwkClass:\ \hmwkTitle}}\\
    \normalsize\vspace{0.1in}\small{Due\ on\ \hmwkDueDate\ }\\
    \vspace{0.1in}\large{\textit{\hmwkClassInstructor\ \hmwkClassTime}}
    \vspace{3in}
}

\author{\hmwkAuthorName}
\date{}

\renewcommand{\part}[1]{\textbf{\large Part \Alph{partCounter}}\stepcounter{partCounter}\\}

%
% Various Helper Commands
%

% Useful for algorithms
\newcommand{\alg}[1]{\textsc{\bfseries \footnotesize #1}}

% For derivatives
\newcommand{\deriv}[1]{\frac{\mathrm{d}}{\mathrm{d}x} (#1)}

% For partial derivatives
\newcommand{\pderiv}[2]{\frac{\partial}{\partial #1} (#2)}

% Integral dx
\newcommand{\dx}{\mathrm{d}x}

% Alias for the Solution section header
\newcommand{\solution}{\textbf{\large Solution}}

% Probability commands: Expectation, Variance, Covariance, Bias
\newcommand{\E}{\mathrm{E}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Cov}{\mathrm{Cov}}
\newcommand{\Bias}{\mathrm{Bias}}

\begin{document}

\maketitle

\pagebreak

\begin{homeworkProblem}
    Why the PoW problem has to consider the hash of previous block? What would happen if the miner only needs to find a nonce such that the one-way hash result of the concatenation of the nonce, the other block header information, and the transactions has enough leading zeros? Any security problem?
    
    \vspace{0.2in}
    
    \textbf{Solution}
    
    \vspace{0.1in}
    
    Most PoW protocols (like BTC) mainly rely on 3 types of hashes: public-private key hashes, Merkle tree hashes and block header hashes. 
    
    \vspace{0.1in}
    
    Public-private key hashes are used as part of the UTXO model to allow people to cryptographically generate addresses. Each receiving address is a 20-byte hash of the public key. These addresses are in turn used to send and receive funds.
    
    \vspace{0.1in}
    
    Merkle tree hashes are used to hash each individual transaction up a Merkle tree into a single Merkle root. This root can be used to check that a transaction has not been tampered with without having to check the entire tree. The Merkle root hash is added to the block header.
    
    \vspace{0.1in}
    
    Block header hashes are generated by hashing the block header twice (SHA256) to create a 32-byte hash (the block header hash). Since the header contains both the Merkle tree hash and the hash of the previous header, the block header hash is used to connect all blocks in the blockchain iteratively in order to establish a tamper-proof chain. 
    
    \vspace{0.1in}
    
    This question is referring to the block header hashes of the previous block. Indeed, the PoW needs to consider the hash of the previous block to ensure that the work being done is being done to mine on top of a particular block (rather than mining on an outdated or invalid block). Otherwise this would allow people to publish solutions to blocks before they are even added to the blockchain and the hierarchy would be lost. 
    
    \vspace{0.1in}
    
    The nonce in BTC is a 4-byte field whose value is by the network so that the hash of the current block is less than or equal to the target difficulty. Indeed, any hash which is smaller than the target hash results in the person who found this hash to win the reward. To find this hash you need to brute force all possible nonce to luckily find a hash smaller than the target. Therefore, the miner indeed needs to find a valid nonce with enough leading zeros (i.e. the small enough hash) that validates the hash result of the concatenation of nonce, block header and transactions. This can be done securely without causing any security issues due to the brute force nature of hashing described previously. However, picking any nonce (even an invalid one) just because it has the right number of leading zeros would definitely cause security issues. This is because if the only thing we look at is the number of leading zeros (and don’t bother checking the hash is valid), then no work actually needs to be done. Users could simply submit any random hash of the correct size which is trivial as it has a complexity $O(1)$. Since we lose the difficulty of PoW, we therefore lose the trust consensus and the BTC protocol is broken. 

\end{homeworkProblem}

\vspace{2in}

\begin{homeworkProblem}
    What would happen if the PoW problem does not consider the timestamp? (Consider the case a malicious miner solves PoW once and put multiple different timestamp) 
    
    \vspace{0.2in}
    
    \textbf{Solution}
    
    \vspace{0.1in}
    
    Timestamps are primarily used by the BTC protocol to establish difficulty. The faster the blocks get published (according to their timestamps) the larger the difficulty will become.
    
    \vspace{0.1in}
    
    If the PoW problem did not consider timestamps it would not be able to track how fast blocks are being published. Thus, it would not be able to adjust difficulty according to the increased computational abilities. As difficulty remains constant while technology improves blocks would be published faster and faster up to the point where blocks will be published every second. 
    
    \vspace{0.1in}
    
    This is highly insecure as blocks no longer have time to propagate through the network. The reason this is insecure is because it violates the “one CPU, one vote” law established by Satoshi Nakamoto. This is because the bottleneck is no longer which chain is the strongest (has the most work). The bottleneck is now who has the best internet connection and can broadcast the most blocks as fast as possible. 
    
    \vspace{0.1in}
    
    Not only is it highly insecure but it is also highly wasteful. It would cause an extremely large amount of orphan blocks that are abandoned due to propagation delay. An interesting list of currently orphaned blocks can be seen here: \url{ https://www.blockchain.com/btc/orphaned-blocks}.
    
    \vspace{0.1in}
    
    In the case where a malicious miner solves a PoW once and submits this solution multiple times with multiple different timestamps, something unusual would occur. I believe that if he attempts to submit multiple PoW solutions the block that propagates the fastest will be the one that gets accepted, regardless of the timestamp. Only one block will survive, irrespective of the timestamp. 
    
    \vspace{0.1in}
    
    However, in the alternative case where a malicious miner submits multiple PoW solutions with multiple different timestamps, something surprising also occurs. If each block is mined on top of the previous block forming a chain and the entire chain is submitted at once with spoofed timestamps then the difficulty could be artificially altered. Indeed, if the spoofed timestamps are very close together (in time) then the difficulty will increase. Conversely, if the spoofed timestamps are highly delayed from each other, then difficulty will decrease as the protocol will believe that blocks have become harder to mine. 


\end{homeworkProblem}

\pagebreak

\begin{homeworkProblem}
    What would happen if the PoW problem does not consider the transactions? 
    
    \vspace{0.2in}
    
    \textbf{Solution}
    
    \vspace{0.1in}
    
    If the PoW problem does not consider transactions then each block would not be examined for double spending within the block. 
    
    \vspace{0.1in}
    
    This is because if PoW solutions that do not consider transactions would be submitted and approved by all miners for any block as long as the other criteria are met, such as the number of leading zeros. Therefore regardless of the transaction contents of the new blocks, newly mined blocks would be added to the blockchain. Indeed, this will cause the presence conflicting transactions (including double spending) in the blockchain.
    
    \vspace{0.1in}
    
    As a consequence, this would allow malicious users to successfully launch double spending attacks without needing over 50\% of the hashing power. These fraudulent transactions would enable theft, contradiction and lying within the blockchain, nullifying the trust consensus originally created.

    \vspace{0.1in}
    
    This would indeed cause a complete collapse of the BTC protocol rending it worthless. 
    
\end{homeworkProblem}

\vspace{0.3in}

\end{document}
